{
  config,
  lib,
  pkgs,
  ...
}: let
  homelabCfg = config.homelab;
  cfg = homelabCfg.services.backup;

  unitsFile =
    pkgs.writeText "backup-service-units.txt"
    (lib.concatStringsSep "\n" cfg.serviceUnits + "\n");

  servicesStopScript = pkgs.writeShellScript "backup-stop-units" ''
    set -euo pipefail

    echo "Stopping units for backup..."

    while IFS= read -r unit; do
      [ -z "$unit" ] && continue

      load_state="$(systemctl show -p LoadState --value "$unit" 2>/dev/null || true)"

      if [ "$load_state" != "loaded" ]; then
        echo " - $unit (not installed) -> skip"
        continue
      fi

      if systemctl is-active --quiet "$unit"; then
        echo " - stopping $unit"
        systemctl stop "$unit"
      else
        echo " - $unit (not active) -> skip"
      fi
    done < ${unitsFile}
  '';

  servicesStartScript = pkgs.writeShellScript "backup-start-units" ''
    set -euo pipefail

    echo "Starting units after backup..."

    while IFS= read -r unit; do
      [ -z "$unit" ] && continue

      load_state="$(systemctl show -p LoadState --value "$unit" 2>/dev/null || true)"

      if [ "$load_state" != "loaded" ]; then
        echo " - $unit (not installed) -> skip"
        continue
      fi

      echo " - starting $unit"
      systemctl start "$unit" || echo "   ! failed to start $unit (continuing)"
    done < ${unitsFile}
  '';

  pgEnabled = config.services.postgresql.enable or false;
  pgBackupEnabled = config.services.postgresqlBackup.enable or false;

  pgDbsRaw = config.services.postgresqlBackup.databases or [];

  # Normalize to list of db names (strings)
  pgDbNames =
    map (
      db:
        if builtins.isString db
        then db
        else db.name
    )
    pgDbsRaw;

  pgUnits = map (name: "postgresqlBackup-${name}.service") pgDbNames;

  pgUnitsFile =
    pkgs.writeText "backup-postgresql-units.txt"
    (lib.concatStringsSep "\n" pgUnits + "\n");

  runPgBackups = pkgs.writeShellScriptBin "run-postgresql-backups" ''
    set -euo pipefail

    echo "PostgreSQL backup orchestration: starting"

    # This script is generated by Nix; these booleans are baked in.
    if [ "${
      if pgEnabled
      then "1"
      else "0"
    }" != "1" ]; then
      echo " - postgresql is disabled -> skip"
      exit 0
    fi

    if [ "${
      if pgBackupEnabled
      then "1"
      else "0"
    }" != "1" ]; then
      echo " - postgresqlBackup is disabled -> skip"
      exit 0
    fi

    if [ "${toString (builtins.length pgDbNames)}" = "0" ]; then
      echo " - no databases configured -> skip"
      exit 0
    fi

    echo " - running backups for ${toString (builtins.length pgDbNames)} database(s)"

    while IFS= read -r unit; do
      [ -z "$unit" ] && continue

      load_state="$(systemctl show -p LoadState --value "$unit" 2>/dev/null || true)"
      if [ "$load_state" != "loaded" ]; then
        echo "   - $unit (not installed) -> skip"
        continue
      fi

      echo "   - starting $unit"
      systemctl start "$unit"
    done < ${pgUnitsFile}

    echo "PostgreSQL backup orchestration: done"
  '';

  zfsDatasets = homelabCfg.zfs.datasets or {};
  resticDatasetEntries = lib.filterAttrs (_: ds: (ds.restic.enable or false)) zfsDatasets;
  datasetNames = lib.attrNames resticDatasetEntries;

  runBackupMainStart = pkgs.writeShellScriptBin "run-backup-main-start" ''
    set -euo pipefail
    echo "Running backup pipeline..."

    # Safety net: if anything fails before we explicitly restart services,
    # this ensures services come back.
    trap '${servicesStartScript} || true' EXIT

    ${runPgBackups}/bin/run-postgresql-backups

    # This script is generated by Nix; these booleans are baked in.
    if [ "${
      if (datasetNames != [])
      then "1"
      else "0"
    }" = "1" ]; then
      echo "Preparing ZFS snapshot mounts for restic backups"

      unit="backup-restic-zfs-dataset-prepare.service"
      load_state="$(systemctl show -p LoadState --value "$unit" 2>/dev/null || true)"

      if [ "$load_state" != "loaded" ]; then
        echo "   - $unit (not installed) -> skip"
      else
        echo "   - starting $unit"
        systemctl start "$unit"
      fi
    fi

    echo "Bringing services back up before restic backup..."
    ${servicesStartScript} || true

    resticUnit="restic-backups-backup.service"
    load_state="$(systemctl show -p LoadState --value "$resticUnit" 2>/dev/null || true)"

    if [ "$load_state" != "loaded" ]; then
      echo "   - $resticUnit (not installed) -> skip"
    else
      echo "   - starting $resticUnit"
      systemctl start "$resticUnit"
    fi

    if [ "${
      if (datasetNames != [])
      then "1"
      else "0"
    }" = "1" ]; then
      echo "Cleanup ZFS snapshot mounts for restic backups"

      unit="backup-restic-zfs-dataset-cleanup.service"
      load_state="$(systemctl show -p LoadState --value "$unit" 2>/dev/null || true)"

      if [ "$load_state" != "loaded" ]; then
        echo "   - $unit (not installed) -> skip"
      else
        echo "   - starting $unit"
        systemctl start "$unit"
      fi
    fi

    echo "Backup pipeline complete."
  '';
in {
  imports = [
    ./options.nix
    ./restic.nix
    ./zfs.nix
  ];

  config = lib.mkIf cfg.enable {
    homelab.services.restic.enable = true;

    systemd = {
      services = {
        backup-system = {
          description = "Homelab backup orchestration";
          wantedBy = [];
          after = ["network-online.target"];
          wants = ["network-online.target"];
          restartIfChanged = false;
          path = [pkgs.systemd];

          serviceConfig = {
            Type = "oneshot";
            ExecStartPre = servicesStopScript;
            ExecStart = "${runBackupMainStart}/bin/run-backup-main-start";
            TimeoutStartSec = "6h";
          };
        };
      };

      timers."backup-system" = {
        wantedBy = ["timers.target"];
        timerConfig = {
          OnCalendar = "*-*-* 02:00:00";
        };
      };
    };
  };
}
