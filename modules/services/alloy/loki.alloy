// -------------------------
// Journald source
// -------------------------
loki.source.journal "systemd" {
	relabel_rules = discovery.relabel.systemd.rules
	forward_to    = [loki.process.systemd.receiver]
}

// -------------------------
// Relabeling rules (journald metadata -> labels)
// -------------------------
discovery.relabel "systemd" {
	targets = []

	rule {
		// Extract systemd unit information into a label
		source_labels = ["__journal__systemd_unit"]
		target_label  = "unit"
	}

    rule {
         // Extract systemd hostname information into a label
         source_labels = ["__journal__hostname"]
         target_label  = "host"
    }

	rule {
		// Extract boot ID information into a label
		source_labels = ["__journal__boot_id"]
		target_label  = "boot_id"
	}

	rule {
		// Extract transport information into a label
		source_labels = ["__journal__transport"]
		target_label  = "transport"
	}

    rule {
         // Default severity label derived from journald priority.
         //
         // This ensures every log stream has a usable `level` label
         // even when the application log line does not include its own
         // structured severity field.
         //
         // Later pipeline stages may override this with the application's
         // own `level=...` or JSON `"level"` value when present.
         source_labels = ["__journal_priority_keyword"]
         target_label  = "level"
    }

	rule {
         // Preserve the raw journald/systemd priority keyword separately.
         //
         // This is useful for debugging and auditing because it represents
         // the transport-level severity assigned by journald itself
         // (info, warning, err, etc.), independent of any application-
         // reported log level.
         //
         // If the application provides its own structured log level,
         // the main `level` label will be overwritten, but this value
         // remains available as `journal_level`.
		source_labels = ["__journal_priority_keyword"]
		target_label  = "journal_level"
	}
}

// -------------------------
// Processing pipeline
// - Extract app "level=warn" from log line (logfmt)
// - Set the stream label "level" from the parsed value
// -------------------------
loki.process "systemd" {

	// -------------------------
	// 1) JSON logs: {"level":"info", ...}
	// -------------------------
	stage.match {
		selector = "{unit=~\".+\"} |~ \"^{\\\"\""

		stage.json {
			expressions = {
				app_level = "level",
			}
		}

		stage.template {
			source   = "app_level"
			template = "{{- $l := lower .Value -}}{{- if eq $l \"warning\" -}}warn{{- else -}}{{$l}}{{- end -}}"
		}

		stage.labels {
			values = {
				level = "app_level",
			}
		}
	}

	// -------------------------
	// 2) logfmt logs: level=warn ts=... msg="..."
	// -------------------------
	stage.match {
		selector = "{unit=~\".+\"} |~ \"(^|[[:space:]])level=\""

		stage.logfmt {
			mapping = {
				app_level = "level",
			}
		}

		stage.template {
			source   = "app_level"
			template = "{{- $l := lower .Value -}}{{- if eq $l \"warning\" -}}warn{{- else -}}{{$l}}{{- end -}}"
		}

		stage.labels {
			values = {
				level = "app_level",
			}
		}
	}

	// -------------------------
	// 3) Fallback: only if level still missing/empty
	// -------------------------
	stage.match {
		// Use regex-empty; more reliable than {level=""} in many setups
		selector = "{level=~\"^$\"}"

		stage.labels {
			values = {
				level = "journal_level",
			}
		}
	}

	forward_to = [loki.write.logs_service.receiver]
}
